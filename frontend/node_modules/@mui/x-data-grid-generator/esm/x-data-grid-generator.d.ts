/// <reference types="react" />
import { GridRenderCellParams as GridRenderCellParams$1, GridCellParams as GridCellParams$1, GridColDef as GridColDef$1, GridRowModel as GridRowModel$1, DataGridProProps } from '@mui/x-data-grid-pro';
import * as React from 'react';
import { IconButtonProps } from '@mui/material/IconButton';
import { MenuItemProps } from '@mui/material/MenuItem';
import { GridRenderEditCellParams as GridRenderEditCellParams$1 } from '@mui/x-data-grid';

declare function renderAvatar(params: GridRenderCellParams$1): JSX.Element;

declare function renderCountry(params: GridRenderCellParams$1): JSX.Element;

declare function renderEmail(params: GridCellParams$1): JSX.Element;

declare function renderIncoterm(params: GridCellParams$1): JSX.Element;

interface DemoLinkProps {
    href: string;
    children: string;
}
declare const DemoLink: React.NamedExoticComponent<DemoLinkProps>;
declare function renderLink(params: GridCellParams$1): JSX.Element;

interface GridFilterItem {
    id?: number | string;
    columnField: string;
    value?: any;
    operatorValue?: string;
}

interface GridFilterInputValueProps {
    item: GridFilterItem;
    applyValue: (value: GridFilterItem) => void;
    apiRef: any;
    focusElementRef?: React.Ref<any>;
}

/**
 * The mode of the cell.
 */
declare type GridCellMode = 'edit' | 'view';
/**
 * The cell value type.
 */
declare type GridCellValue = string | number | boolean | Date | null | undefined | object;

/**
 * The key value object representing the data of a row.
 */
declare type GridRowModel<T = {
    [key: string]: any;
}> = T;
interface GridRowTreeNodeConfig {
    /**
     * The grid row id.
     */
    id: GridRowId;
    /**
     * The id of the row children.
     */
    children?: GridRowId[];
    /**
     * The row id of the parent (null if this row is a top level row).
     */
    parent: GridRowId | null;
    /**
     * Current expansion status of the row.
     */
    childrenExpanded?: boolean;
    /**
     * 0-based depth of the row in the tree.
     */
    depth: number;
    /**
     * The key used to group the children of this row.
     */
    groupingKey: GridKeyValue;
    /**
     * The field used to group the children of this row.
     * Is `null` if no field has been used to group the children of this row.
     */
    groupingField: string | null;
    /**
     * If `true`, this node has been automatically added to fill a gap in the tree structure.
     */
    isAutoGenerated?: boolean;
}
/**
 * The type of Id supported by the grid.
 */
declare type GridRowId = string | number;

interface GridEditCellProps {
    value: GridCellValue;
    [prop: string]: any;
}

/**
 * Object passed as parameter in the column [[GridColDef]] cell renderer.
 */
interface GridCellParams<V = any, R = any, F = V> {
    /**
     * The grid row id.
     */
    id: GridRowId;
    /**
     * The column field of the cell that triggered the event
     */
    field: string;
    /**
     * The cell value, but if the column has valueGetter, use getValue.
     */
    value: V;
    /**
     * The cell value formatted with the column valueFormatter.
     */
    formattedValue: F;
    /**
     * The row model of the row that the current cell belongs to.
     */
    row: GridRowModel<R>;
    /**
     * The node of the row that the current cell belongs to.
     */
    rowNode: GridRowTreeNodeConfig;
    /**
     * The column of the row that the current cell belongs to.
     */
    colDef: GridStateColDef;
    /**
     * If true, the cell is editable.
     */
    isEditable?: boolean;
    /**
     * The mode of the cell.
     */
    cellMode: GridCellMode;
    /**
     * If true, the cell is the active element.
     */
    hasFocus: boolean;
    /**
     * the tabIndex value.
     */
    tabIndex: 0 | -1;
    /**
     * Get the cell value of a row and field.
     * @param {GridRowId} id The row id.
     * @param {string} field The field.
     * @returns {GridCellValue} The cell value.
     */
    getValue: (id: GridRowId, field: string) => GridCellValue;
}
/**
 * GridCellParams containing api.
 */
interface GridRenderCellParams<V = any, R = any, F = V> extends GridCellParams<V, R, F> {
    /**
     * GridApi that let you manipulate the grid.
     */
    api: any;
}
/**
 * GridEditCellProps containing api.
 */
interface GridRenderEditCellParams extends GridEditCellProps {
    /**
     * GridApi that let you manipulate the grid.
     */
    api: any;
}
/**
 * Alias of GridRenderCellParams.
 */
declare type GridValueGetterParams = Omit<GridRenderCellParams, 'formattedValue' | 'isEditable'>;
/**
 * Object passed as parameter in the column [[GridColDef]] value setter callback.
 */
interface GridValueSetterParams {
    /**
     * The new cell value.
     */
    value: GridCellValue;
    /**
     * The row that is being editted.
     */
    row: GridRowModel;
}
/**
 * Object passed as parameter in the column [[GridColDef]] value formatter callback.
 */
interface GridValueFormatterParams {
    /**
     * The grid row id.
     * It is not available when the value formatter is called by the filter panel.
     */
    id?: GridRowId;
    /**
     * The column field of the cell that triggered the event
     */
    field: string;
    /**
     * The cell value, but if the column has valueGetter, use getValue.
     */
    value: GridCellValue;
    /**
     * GridApi that let you manipulate the grid.
     */
    api: any;
}
/**
 * Object passed as parameter in the column [[GridColDef]] edit cell props change callback.
 */
interface GridPreProcessEditCellProps {
    /**
     * The grid row id.
     */
    id: GridRowId;
    /**
     * The row that is being editted.
     */
    row: GridRowModel;
    /**
     * The edit cell props.
     */
    props: GridEditCellProps;
}

interface GridFilterOperator {
    label?: string;
    value: string;
    getApplyFilterFn: (filterItem: GridFilterItem, column: GridStateColDef) => null | ((params: GridCellParams) => boolean);
    InputComponent?: React.JSXElementConstructor<GridFilterInputValueProps>;
    InputComponentProps?: Record<string, any>;
}

/**
 * A function used to process cellClassName params.
 */
declare type GridCellClassFn = (params: GridCellParams) => string;
/**
 * The union type representing the [[GridColDef]] cell class type.
 */
declare type GridCellClassNamePropType = string | GridCellClassFn;

/**
 * Object passed as parameter in the column [[GridColDef]] header renderer.
 */
interface GridColumnHeaderParams {
    /**
     * The column field of the column that triggered the event
     */
    field: string;
    /**
     * The column of the current header component.
     */
    colDef: GridStateColDef;
}

/**
 * A function used to process headerClassName params.
 */
declare type GridColumnHeaderClassFn = (params: GridColumnHeaderParams) => string;
/**
 * The union type representing the [[GridColDef]] column header class type.
 */
declare type GridColumnHeaderClassNamePropType = string | GridColumnHeaderClassFn;

interface GridSortCellParams {
    id: GridRowId;
    field: string;
    value: GridCellValue;
    api: any;
}
/**
 * The type of the sort comparison function.
 */
declare type GridComparatorFn = (v1: GridCellValue, v2: GridCellValue, cellParams1: GridSortCellParams, cellParams2: GridSortCellParams) => number;

declare type GridNativeColTypes = 'string' | 'number' | 'date' | 'dateTime' | 'boolean' | 'singleSelect' | 'actions';
declare type GridColType = GridNativeColTypes | string;

/**
 * Object passed as parameter in the row callbacks.
 */
interface GridRowParams<R extends GridRowModel = GridRowModel> {
    /**
     * The grid row id.
     */
    id: GridRowId;
    /**
     * The row model of the row that the current cell belongs to.
     */
    row: R;
    /**
     * All grid columns.
     */
    columns: GridColumns;
    /**
     * Get the cell value of a row and field.
     * @param {GridRowId} id The row id.
     * @param {string} field The field.
     * @returns {GridCellValue} The cell value.
     */
    getValue: (id: GridRowId, field: string) => GridCellValue;
}

/**
 * Object passed as parameter of the valueOptions function for singleSelect column.
 */
interface GridValueOptionsParams {
    /**
     * The field of the column to which options will be provided
     */
    field: string;
    /**
     * The grid row id.
     */
    id?: GridRowId;
    /**
     * The row model of the row that the current cell belongs to.
     */
    row?: GridRowModel;
}

declare type GridActionsCellItemProps = {
    label: string;
    icon?: React.ReactElement;
} & (({
    showInMenu?: false;
    icon: React.ReactElement;
} & IconButtonProps) | ({
    showInMenu: true;
} & MenuItemProps));

/**
 * Alignment used in position elements in Cells.
 */
declare type GridAlignment = 'left' | 'right' | 'center';
declare type ValueOptions = string | number | {
    value: any;
    label: string;
};
/**
 * Value that can be used as a key for grouping rows
 */
declare type GridKeyValue = string | number | boolean;
/**
 * Column Definition interface.
 */
interface GridColDef {
    /**
     * The column identifier. It's used to map with [[GridRowModel]] values.
     */
    field: string;
    /**
     * The title of the column rendered in the column header cell.
     */
    headerName?: string;
    /**
     * The description of the column rendered as tooltip if the column header name is not fully displayed.
     */
    description?: string;
    /**
     * Set the width of the column.
     * @default 100
     */
    width?: number;
    /**
     * If set, it indicates that a column has fluid width. Range [0, âˆž).
     */
    flex?: number;
    /**
     * Sets the minimum width of a column.
     * @default 50
     */
    minWidth?: number;
    /**
     * If `true`, hide the column.
     * @default false
     */
    hide?: boolean;
    /**
     * If `true`, the column is sortable.
     * @default true
     */
    sortable?: boolean;
    /**
     * If `true`, the column is resizable.
     * @default true
     */
    resizable?: boolean;
    /**
     * If `true`, the cells of the column are editable.
     * @default false
     */
    editable?: boolean;
    /**
     * A comparator function used to sort rows.
     */
    sortComparator?: GridComparatorFn;
    /**
     * Type allows to merge this object with a default definition [[GridColDef]].
     * @default 'string'
     */
    type?: GridColType;
    /**
     * To be used in combination with `type: 'singleSelect'`. This is an array (or a function returning an array) of the possible cell values and labels.
     */
    valueOptions?: Array<ValueOptions> | ((params: GridValueOptionsParams) => Array<ValueOptions>);
    /**
     * Allows to align the column values in cells.
     */
    align?: GridAlignment;
    /**
     * Function that allows to get a specific data instead of field to render in the cell.
     * @param {GridValueGetterParams} params Object containing parameters for the getter.
     * @returns {GridCellValue} The cell value.
     */
    valueGetter?: (params: GridValueGetterParams) => GridCellValue;
    /**
     * Function that allows to customize how the entered value is stored in the row.
     * It only works with cell/row editing.
     * @param {GridValueSetterParams} params Object containing parameters for the setter.
     * @returns {GridRowModel} The row with the updated field.
     */
    valueSetter?: (params: GridValueSetterParams) => GridRowModel;
    /**
     * Function that allows to apply a formatter before rendering its value.
     * @param {GridValueFormatterParams} params Object containing parameters for the formatter.
     * @returns {GridCellValue} The formatted value.
     */
    valueFormatter?: (params: GridValueFormatterParams) => GridCellValue;
    /**
     * Function that takes the user-entered value and converts it to a value used internally.
     * @param {GridCellValue} value The user-entered value.
     * @param {GridCellParams} params The params when called before saving the value.
     * @returns {GridCellValue} The converted value to use internally.
     */
    valueParser?: (value: GridCellValue, params?: GridCellParams) => GridCellValue;
    /**
     * Class name that will be added in cells for that column.
     */
    cellClassName?: GridCellClassNamePropType;
    /**
     * Allows to override the component rendered as cell for this column.
     * @param {GridRenderCellParams} params Object containing parameters for the renderer.
     * @returns {React.ReactNode} The element to be rendered.
     */
    renderCell?: (params: GridRenderCellParams) => React.ReactNode;
    /**
     * Allows to override the component rendered in edit cell mode for this column.
     * @param {GridRenderEditCellParams} params Object containing parameters for the renderer.
     * @returns {React.ReactNode} The element to be rendered.
     */
    renderEditCell?: (params: GridRenderEditCellParams) => React.ReactNode;
    /**
     * Callback fired when the edit props of the cell changes.
     * It allows to process the props that saved into the state.
     * @param {GridPreProcessEditCellProps} params Object contaning parameters of the cell being editted.
     * @returns {GridEditCellProps | Promise<GridEditCellProps>} The new edit cell props.
     */
    preProcessEditCellProps?: (params: GridPreProcessEditCellProps) => GridEditCellProps | Promise<GridEditCellProps>;
    /**
     * Class name that will be added in the column header cell.
     */
    headerClassName?: GridColumnHeaderClassNamePropType;
    /**
     * Allows to render a component in the column header cell.
     * @param {GridColumnHeaderParams} params Object containing parameters for the renderer.
     * @returns {React.ReactNode} The element to be rendered.
     */
    renderHeader?: (params: GridColumnHeaderParams) => React.ReactNode;
    /**
     * Header cell element alignment.
     */
    headerAlign?: GridAlignment;
    /**
     * Toggle the visibility of the sort icons.
     * @default false
     */
    hideSortIcons?: boolean;
    /**
     * If `true`, the column menu is disabled for this column.
     * @default false
     */
    disableColumnMenu?: boolean;
    /**
     * If `true`, the column is filterable.
     * @default true
     */
    filterable?: boolean;
    /**
     * Allows setting the filter operators for this column.
     */
    filterOperators?: GridFilterOperator[];
    /**
     * If `true`, this column cannot be reordered.
     * @default false
     */
    disableReorder?: boolean;
    /**
     * If `true`, this column will not be included in exports.
     * @default false
     */
    disableExport?: boolean;
}
interface GridActionsColDef extends GridColDef {
    /**
     * Type allows to merge this object with a default definition [[GridColDef]].
     * @default 'actions'
     */
    type: 'actions';
    /**
     * Function that returns the actions to be shown.
     * @param {GridRowParams} params The params for each row.
     * @returns {React.ReactElement<GridActionsCellItemProps>[]} An array of [[GridActionsCell]] elements.
     */
    getActions: (params: GridRowParams) => React.ReactElement<GridActionsCellItemProps>[];
}
declare type GridEnrichedColDef = GridColDef | GridActionsColDef;
declare type GridColumns = GridEnrichedColDef[];
declare type GridStateColDef = GridEnrichedColDef & {
    computedWidth: number;
};

declare function renderPnl(params: GridCellParams): JSX.Element;

declare function renderProgress(params: GridCellParams$1): JSX.Element;

declare function renderRating(params: GridCellParams$1): JSX.Element;

declare function renderStatus(params: GridCellParams$1): JSX.Element;

declare function renderTotalPrice(params: GridCellParams): JSX.Element;

declare function renderEditCurrency(params: GridRenderEditCellParams$1): JSX.Element;

declare function renderEditProgress(params: GridRenderEditCellParams$1): JSX.Element;

declare function renderEditStatus(params: GridRenderEditCellParams$1): JSX.Element;

declare function renderEditIncoterm(params: GridRenderEditCellParams$1): JSX.Element;

declare function renderEditRating(params: GridRenderEditCellParams$1): JSX.Element;

declare function renderEditCountry(params: GridRenderEditCellParams$1): JSX.Element;

interface GridDataGeneratorContext {
    /**
     * Values already attributed to this column.
     * Only defined if the column has the uniqueness mode activated.
     * The keys represents the random value and the value represents the amount of rows that already have this value.
     * This allows to data generators to add a suffix to the returned value to force the uniqueness.
     */
    values?: Record<string, number>;
}
interface GridColDefGenerator extends GridColDef$1 {
    generateData?: (row: any, context: GridDataGeneratorContext) => any;
    /**
     * If `true`, each row will have a distinct value
     * If several rows are generated with the same value, then a suffix will be added to the 2nd, 3rd, ...
     * @default false
     */
    dataGeneratorUniquenessEnabled?: boolean;
}

declare type ColumnDataGenerator<Value> = (data: any, context: GridDataGeneratorContext) => Value;
declare const random: (min: number, max: number) => number;
declare const randomInt: (min: number, max: number) => number;
declare const randomPrice: (min?: number, max?: number) => number;
declare const randomRate: () => number;
declare const randomDate: (start: Date, end: Date) => Date;
declare const randomArrayItem: <T>(arr: T[]) => T;
declare const randomBoolean: () => boolean;
declare const randomColor: () => "#e91e63" | "#2196f3" | "#ff9800" | "#f44336" | "#4caf50" | "#03a9f4" | "#9c27b0";
declare const randomId: () => string;
declare const randomDesk: () => string;
declare const randomCommodity: () => string;
declare const randomTraderName: () => string;
declare const randomUserName: () => string;
declare const randomEmail: () => string;
declare const randomUrl: () => string;
declare const randomPhoneNumber: () => string;
declare const randomUnitPrice: () => number;
declare const randomUnitPriceCurrency: () => string;
declare const randomQuantity: () => number;
declare const randomFeeRate: () => number;
declare const randomIncoterm: () => string;
declare const randomStatusOptions: () => string;
declare const randomPnL: () => number;
declare const randomMaturityDate: () => Date;
declare const randomTradeDate: () => Date;
declare const randomBrokerId: () => string;
declare const randomCompanyName: () => string;
declare const randomCountry: () => {
    value: string;
    code: string;
    label: string;
    phone: string;
    suggested?: undefined;
} | {
    value: string;
    code: string;
    label: string;
    phone: string;
    suggested: boolean;
};
declare const randomCurrency: () => string;
declare const randomAddress: () => string;
declare const randomCity: () => string;
declare const randomTaxCode: () => string;
declare const randomContractType: () => string;
declare const randomRateType: () => string;
declare const randomCreatedDate: () => Date;
declare const randomUpdatedDate: () => Date;
declare const randomJobTitle: () => string;
declare const randomRating: () => number;
declare const randomName: ColumnDataGenerator<string>;
declare const generateFilledQuantity: (data: {
    quantity: number;
}) => number;
declare const generateIsFilled: (data: {
    quantity: number;
    filledQuantity: number;
}) => boolean;

interface GridDemoData {
    rows: GridRowModel$1[];
    columns: GridColDefGenerator[];
}
declare function getRealGridData(rowLength: number, columns: GridColDefGenerator[]): Promise<GridDemoData>;

declare const getCommodityColumns: (editable?: boolean) => GridColDefGenerator[];

declare const getEmployeeColumns: () => GridColDefGenerator[];

interface AddPathToDemoDataOptions {
    /**
     * The field used to generate the path
     * If not defined, the tree data will not be built
     */
    groupingField?: string;
    /**
     * The depth of the tree
     * @default: 1
     */
    maxDepth?: number;
    /**
     * The average amount of children in a node
     * @default: 2
     */
    averageChildren?: number;
}
interface DemoTreeDataValue extends Pick<DataGridProProps, 'getTreeDataPath' | 'treeData' | 'groupingColDef'>, GridDemoData {
}

declare type DemoDataReturnType = {
    data: DemoTreeDataValue;
    loading: boolean;
    setRowLength: (count: number) => void;
    loadNewData: () => void;
};
declare type DataSet = 'Commodity' | 'Employee';
interface UseDemoDataOptions {
    dataSet: DataSet;
    rowLength: number;
    maxColumns?: number;
    editable?: boolean;
    treeData?: AddPathToDemoDataOptions;
}
declare const useDemoData: (options: UseDemoDataOptions) => DemoDataReturnType;

export { DemoDataReturnType, DemoLink, GridColDefGenerator, GridDataGeneratorContext, GridDemoData, UseDemoDataOptions, generateFilledQuantity, generateIsFilled, getCommodityColumns, getEmployeeColumns, getRealGridData, random, randomAddress, randomArrayItem, randomBoolean, randomBrokerId, randomCity, randomColor, randomCommodity, randomCompanyName, randomContractType, randomCountry, randomCreatedDate, randomCurrency, randomDate, randomDesk, randomEmail, randomFeeRate, randomId, randomIncoterm, randomInt, randomJobTitle, randomMaturityDate, randomName, randomPhoneNumber, randomPnL, randomPrice, randomQuantity, randomRate, randomRateType, randomRating, randomStatusOptions, randomTaxCode, randomTradeDate, randomTraderName, randomUnitPrice, randomUnitPriceCurrency, randomUpdatedDate, randomUrl, randomUserName, renderAvatar, renderCountry, renderEditCountry, renderEditCurrency, renderEditIncoterm, renderEditProgress, renderEditRating, renderEditStatus, renderEmail, renderIncoterm, renderLink, renderPnl, renderProgress, renderRating, renderStatus, renderTotalPrice, useDemoData };
